#!/usr/local/node/bin/node

const { info, error } = require("../tools/colors");
const fs = require("fs");
const path = require("path");
const execSync = require("child_process").execSync;
const yaml = require("js-yaml");
const requests = require("../tools/requests");


/**
 *  @readme
 *      GitHookProduct: 自动化部署项目的自动化部署处理方案, 自身部署自身
 *          git_hooks_env: 给git-hooks的环境变量    
 *          deploy_pathname: 需要执行的其他配置
 *          branchs: 需要部署的分支, 暂时不处理, 默认全部是master
 *  
 *      DeployProject: 自动化部署其余项目
 *          __notice_hosts: 通知其他主机重新部署项目
 *          __notice_listener_service: 通知其他主机重新部署监控部署的服务进程
 * 
 *      PostReceive: hook: post-receive 
 * 
 */


// 自动化部署系统 - 项目路径
const hooks_dirname =  "/home/git/product/git-hooks";

class GitHookProject {

    constructor (branchs){

        this.git_hooks_env = "\
            export PATH=/usr/local/node/bin:/usr/local/sbin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin:/usr/local/bin \
            && unset GIT_DIR \
            && bash -c";

        this.deploy_pathname = "deploy.yaml";

        this.branchs = branchs;

    }

    run (){

        info("[info] 进入目录 %s", hooks_dirname);
        process.chdir(hooks_dirname);

        info("[info] 拉取更新");
        console.log(execSync(`${this.git_hooks_env} 'git pull'`).toString());

        const deploy_pathname = this.deploy_pathname;

        try {

            info("[info] 检查部署文件: %s 是否存在 ...", deploy_pathname);
            fs.accessSync(deploy_pathname);
            const f = fs.readFileSync(deploy_pathname);
            const task = yaml.safeLoad(f);
            info("[info] %s 存在 ...", deploy_pathname);

            if (task.run.length){
                for (let cmd of task.run){
                    info("[info] 执行命令: %s", cmd);
                    console.log(execSync(`${this.git_hooks_env} '${cmd}'`).toString());
                }
            }

            info("[info] success ...");

        } catch (err){
            error("[warning] %s 不存在, end ...", deploy_pathname);
        }
    }

}


class DeployProject {

    constructor (warehourse, branchs){

        this.warehourse = warehourse;
        this.branchs = branchs;

        // 分布式 - 配置文件
        this.config = "config.yaml";
    
    }

    async __notice_hosts (task){

        for (const origin of task.ips){

            info("[info] 开始通知 origin: %s", origin);

            let resTxt = await requests(origin, task.api_post_receive, {
                warehourse: this.warehourse,
                branchs: this.branchs
            }, "POST");

            let res = JSON.parse(resTxt);
            if (!res.errcode){
                info("[info] success, origin: %s, path: %s", origin, task.api_post_receive);
                continue;
            }
            error("[warning] origin: %s, message: %s", origin, res.msg);
        }

    }

    async __notice_listener_service (task){

        let counts = 0;

        for (const origin of task.ips){

            info("[info] 开始通知 origin: %s 重新部署 分布式部署系统的监控进程", origin);
            counts++;

            requests(origin, task.api_post_receive, {
                warehourse: this.warehourse,
                branchs: this.branchs
            }, "POST").catch(err => {
                counts--;
                if (!counts){
                    info("[info] 开始检测各监控进程是否都正常启动...");
                    this.__heartbeat_mechanism(task);
                }
            });

        }

    }

    async __heartbeat_mechanism (task){

        const bad = [];
        let counts = 0;

        await new Promise(resolve => {
            info("[info] 添加延迟，5s");
            setTimeout(resolve, 5000);
        });
        
        for (const origin of task.ips){
            counts++;
            requests(origin, task.api_is_running).catch(err => {
                bad.push(origin);
                counts--;
                if (!counts){
                    const s = bad.length > 0 
                        ? `[warning] 共 ${task.ips.length} 个，存在 ${bad.length} 个监控进程启动失败, 详情:\r\n${bad.join(" , ")}`
                        : `[warning] 共 ${task.ips.length} 个， 监控进程，全部重新部署完成`;
                    error(s);
                }
            });
        }

    }

    async run (){

        try {

            const config_pathanme = path.resolve(hooks_dirname, this.config)
            
            info("[info] 检查配置文件 %s 是否存在", config_pathanme);
            fs.accessSync(config_pathanme);
            info("[info] 配置文件 %s 存在", config_pathanme);

            const f = fs.readFileSync(config_pathanme);
            const task = yaml.safeLoad(f);

            if (task.ips.length){
                const go = this.warehourse !== "hooks-service" 
                    ? this.__notice_hosts.bind(this, task) 
                    : this.__notice_listener_service.bind(this, task);
                await go();
            }

            info("[info] all success ...");

        } catch (err){
            error("[warning] 根据配置文件通知IP更新代码失败, end ...", err.toString());
        }
    }

}

class PostReceive {

    constructor (branchs){
        this.warehourse = null;
        this.branchs = branchs;
    }

    // 获取仓库名称
    __getWarehourseName (){

        let paths = process.cwd().split("/");
        this.warehourse = paths[paths.length - 1].split(".git")[0];

    }

    run (){

        this.__getWarehourseName();
        info("[info] push仓库名: %s, 需要更新的分支: %s", this.warehourse, this.branchs.join(" , "));

        if (this.warehourse === "git-hooks") return new GitHookProject(this.branchs).run();

        new DeployProject(this.warehourse, this.branchs).run();

    }

}

{
    if ( !module.parents ){

        (async () => {
            
            // 获取push的分支, 可以一次push多个分支
            process.stdin.setEncoding('utf8');
            const branchs = await new Promise(resolve => {
                const chunks = [];
                process.stdin.on('readable', () => {
                    const chunk = process.stdin.read();
                    if (chunk !== null) {
                        chunks.push(chunk);
                    }
                });
    
                process.stdin.on('end', () => {
                    const arr = chunks.join("").trim().split(" ");
                    const branchs = arr.splice(2);
                    resolve(branchs);
                });
            });

            // 处理 post-receive
            try {
                new PostReceive(branchs).run();
            } catch (err){
                error("[error] 发生了错误", err.toString());
            }
            
        })();
    }
}



